## Базовый фукнционал


### Леша - Клиент

#### Интерфейс:
- Отображать и передвигать кружочки.
- Записывать и проигрывать звук.
- Кнопка для выключение микрофона и для выключения динамика.
- [Доп. опция] Мастер мод для управления чужими кружочками.

#### Внутренняя архитектура:
- Реализовать MVC модель.
- Контроллер посылает сигнал модели через очередь.
- Сетевой интерфейс тоже посылает сигнал через очередь.
- Отдельный аудио-контроллер, который 
  а) записывает аудио и посылает через очередь на сетевой интерфейс. В сообщение как минимум аудио, id клиента, момент записи выравненный по ntp.
  б) принимает аудио с очереди и проигрывает его.


### Федя - Аудио

#### Сервер.

- Даны позиции n участников, k участников что-то говорит. Нужно расчитать микс сигнала на n участников с учетом расстояний и нормализацией сигнала.
	- Продумать нормализацию. Если не делить, будет очень громко. Если делить на k, получится, что если один стоит рядом, а другие убежали. Стоящий рядом говорит с громкостью 1 / k. 

	Скорее всего нужно просуммировать коэффициенты, а потом поделить громкость на эту сумму (если она больше единицы). Проверить экспериментально, возможно улучшить.

- Архитектура. Нужно сделать MPMC очереди (одну или n), из этой очереди выгребать все аудиофайлы, раскидывать их уже по очередям на каждого участника. Это будет буфер. Когда подходит время, вынимать из буфера, что есть и закидывать в микшер.
	Два нюанса для настройки. 
	1. Сколько времени дать на окно буфера. Для начала можно сделать окно константой (200мс).
	2. Что делать с опоздающими, а) для простоты дропнуть; б) более сложный вариант, передать, если фрагмент последний или сжать по времени, если нет.

- На выход послать n аудио сообщений с id клиента, которому они идут.

#### Клиент

- Реализовать модуль кодировки в wav и mp3 на клиентской части.
- Решить вместе с Лешей задачу, как проигрывать непрерывно поток аудиофайлов.
- На клиентской части тоже буферизовать аудиофайлы, дать им некоторое окно, когда они могут прийти и проигрывать с соответствующей задержкой.
- Опаздывающие фрагменты либо дропать, либо проигрывать в ускоренном режиме. Для начала дропать.
- Аудиопроигрыватель должен работать в отдельном от интерфейса потоке.


### Никита - Сетевая часть

Собрать работающее клиент-серверное приложение, которое могло бы обмениваться сообщениями.Реализовать базовое клиент-сереверное сообщение.

#### Базовые функции клиента:
- получить id на свой кружочек;
- отослать изменение координат кружочков;
- получить новые координаты кружочков;
- отослать аудиофайл;
- получить аудиофайл;

Возмонжо, нужно будет разделить аудиопоток и сигнальный поток. Т.е. открыть минимум два порта. Или 1 сигнальный + k для аудио.

#### Опсы
- Спросить в университете, можно ли получить доступ к публичному ip с возможностью открыть часть портов.
- Убедиться, что мы можем посылать туда и принимать там сообщения хотя бы через netcat.
- Потом туда надо будет загрузить и запустить там серверную часть.

#### Сервер

- Реализовать систему назначения id (неплохо бы уметь сохранять id и координаты клиента, если связь временно оборвалась).
- Обновлять координаты в соответствии с поддаными данными от клиента.
- На серверной стороне получать аудио-файлы и скармливать его микшеру (микшер должен работать в отдельном потоке). Проще всего это делать через MPMC очередь.
- Забирать файлы со стороны микшера и отправлять их клиентам.
- Отдельная большая плюшка за персистентность. Сервер должен сохранять мета-данные (не аудио). Мы предполагаем, что он может в любой момент упасть, и все, что будет в памяти мы потеряем. Можно писать просто в файлик. Можно развернуть sqllite.

#### Клиент

- Посмотреть, что нужно Феде и Леше и написать часть по приему и распределению сообщений.